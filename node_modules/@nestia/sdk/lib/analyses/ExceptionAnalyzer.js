"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExceptionAnalyzer = void 0;
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const MetadataCollection_1 = require("typia/lib/factories/MetadataCollection");
const MetadataFactory_1 = require("typia/lib/factories/MetadataFactory");
const ImportAnalyzer_1 = require("./ImportAnalyzer");
var ExceptionAnalyzer;
(function (ExceptionAnalyzer) {
    ExceptionAnalyzer.analyze = (project) => (genericDict, importDict) => (controller, func) => (declaration) => {
        var _a;
        const output = {};
        for (const decorator of (_a = declaration.modifiers) !== null && _a !== void 0 ? _a : [])
            if (typescript_1.default.isDecorator(decorator))
                analyzeTyped(project)(genericDict, importDict)(controller, func)(output)(decorator);
        return output;
    };
    const analyzeTyped = (project) => (genericDict, importDict) => (controller, func) => (output) => (decorator) => {
        var _a, _b;
        // CHECK DECORATOR
        if (!typescript_1.default.isCallExpression(decorator.expression))
            return false;
        else if (((_a = decorator.expression.typeArguments) !== null && _a !== void 0 ? _a : []).length !== 1)
            return false;
        // CHECK SIGNATURE
        const signature = project.checker.getResolvedSignature(decorator.expression);
        if (!signature || !signature.declaration)
            return false;
        else if (path_1.default
            .resolve(signature.declaration.getSourceFile().fileName)
            .indexOf(TYPED_EXCEPTION_PATH) === -1)
            return false;
        // GET TYPE INFO
        const status = getStatus(project.checker)((_b = decorator.expression.arguments[0]) !== null && _b !== void 0 ? _b : null);
        if (status === null)
            return false;
        const node = decorator.expression.typeArguments[0];
        const type = project.checker.getTypeFromTypeNode(node);
        if (type.isTypeParameter()) {
            project.errors.push({
                file: controller.file,
                controller: controller.name,
                function: func.name,
                message: "TypedException() without generic argument specification.",
            });
            return false;
        }
        const tuple = ImportAnalyzer_1.ImportAnalyzer.analyze(project.checker, genericDict, importDict, type);
        if (tuple === null ||
            (project.config.clone !== true &&
                (tuple.typeName === "__type" || tuple.typeName === "__object"))) {
            project.errors.push({
                file: controller.file,
                controller: controller.name,
                function: func.name,
                message: "TypeException() with implicit (unnamed) type.",
            });
            return false;
        }
        // DO ASSIGN
        const matched = Object.entries(func.exceptions)
            .filter(([key]) => status === key)
            .map(([_key, value]) => value);
        for (const m of matched)
            output[m.status] = {
                type: tuple.type,
                typeName: tuple.typeName,
                contentType: "application/json",
                description: m.description,
            };
        return true;
    };
    const getStatus = (checker) => (expression) => {
        if (expression === null)
            return null;
        const type = checker.getTypeAtLocation(expression);
        const result = MetadataFactory_1.MetadataFactory.analyze(checker)({
            escape: true,
            constant: true,
            absorb: true,
        })(new MetadataCollection_1.MetadataCollection())(type);
        if (false === result.success)
            return null;
        const meta = result.data;
        if (meta.constants.length === 1)
            return meta.constants[0].values[0].toString();
        else if (meta.escaped && meta.escaped.returns.constants.length === 1)
            return meta.escaped.returns.constants[0].values[0].toString();
        else if (typescript_1.default.isStringLiteral(expression))
            return expression.text;
        else if (typescript_1.default.isNumericLiteral(expression)) {
            const value = Number(expression.text.split("_").join(""));
            if (false === isNaN(value))
                return value.toString();
        }
        return null;
    };
})(ExceptionAnalyzer || (exports.ExceptionAnalyzer = ExceptionAnalyzer = {}));
const TYPED_EXCEPTION_PATH = path_1.default.join("node_modules", "@nestia", "core", "lib", "decorators", "TypedException.d.ts");
//# sourceMappingURL=ExceptionAnalyzer.js.map