"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkTypeProgrammer = void 0;
const typescript_1 = __importDefault(require("typescript"));
const ExpressionFactory_1 = require("typia/lib/factories/ExpressionFactory");
const TypeFactory_1 = require("typia/lib/factories/TypeFactory");
const Escaper_1 = require("typia/lib/utils/Escaper");
const FilePrinter_1 = require("./FilePrinter");
var SdkTypeProgrammer;
(function (SdkTypeProgrammer) {
    /* -----------------------------------------------------------
      FACADE
    ----------------------------------------------------------- */
    SdkTypeProgrammer.write = (config) => (importer) => (meta, parentEscaped = false) => {
        const union = [];
        // COALESCES
        if (meta.any)
            union.push(TypeFactory_1.TypeFactory.keyword("any"));
        if (meta.nullable)
            union.push(writeNode("null"));
        if (meta.isRequired() === false)
            union.push(writeNode("undefined"));
        if (parentEscaped === false && meta.escaped)
            union.push(write_escaped(config)(importer)(meta.escaped));
        // ATOMIC TYPES
        for (const c of meta.constants)
            for (const value of c.values)
                union.push(write_constant(value));
        for (const tpl of meta.templates)
            union.push(write_template(config)(importer)(tpl));
        for (const atom of meta.atomics)
            union.push(write_atomic(importer)(atom));
        // OBJECT TYPES
        for (const tuple of meta.tuples)
            union.push(write_tuple(config)(importer)(tuple));
        for (const array of meta.arrays)
            union.push(write_array(config)(importer)(array));
        for (const object of meta.objects)
            if (object.name === "__type" ||
                object.name.startsWith("__type.") ||
                object.name === "__object" ||
                object.name.startsWith("__object."))
                union.push(SdkTypeProgrammer.write_object(config)(importer)(object));
            else
                union.push(write_alias(config)(importer)(object));
        for (const alias of meta.aliases)
            union.push(write_alias(config)(importer)(alias));
        for (const native of meta.natives)
            if (native === "Blob" || native === "File")
                union.push(write_native(native));
        return union.length === 1
            ? union[0]
            : typescript_1.default.factory.createUnionTypeNode(union);
    };
    SdkTypeProgrammer.write_object = (config) => (importer) => (object) => {
        var _a;
        const regular = object.properties.filter((p) => p.key.isSoleLiteral());
        const dynamic = object.properties.filter((p) => !p.key.isSoleLiteral());
        return FilePrinter_1.FilePrinter.description(regular.length && dynamic.length
            ? typescript_1.default.factory.createIntersectionTypeNode([
                write_regular_property(config)(importer)(regular),
                ...dynamic.map(write_dynamic_property(config)(importer)),
            ])
            : dynamic.length
                ? typescript_1.default.factory.createIntersectionTypeNode(dynamic.map(write_dynamic_property(config)(importer)))
                : write_regular_property(config)(importer)(regular), writeComment([])((_a = object.description) !== null && _a !== void 0 ? _a : null, object.jsDocTags));
    };
    const write_escaped = (config) => (importer) => (meta) => {
        if (meta.original.size() === 1 &&
            meta.original.natives.length === 1 &&
            meta.original.natives[0] === "Date")
            return typescript_1.default.factory.createIntersectionTypeNode([
                TypeFactory_1.TypeFactory.keyword("string"),
                writeTag(importer)({
                    name: "Format",
                    value: "date-time",
                }),
            ]);
        return SdkTypeProgrammer.write(config)(importer)(meta.returns, true);
    };
    /* -----------------------------------------------------------
      ATOMICS
    ----------------------------------------------------------- */
    const write_constant = (value) => {
        if (typeof value === "boolean")
            return typescript_1.default.factory.createLiteralTypeNode(value ? typescript_1.default.factory.createTrue() : typescript_1.default.factory.createFalse());
        else if (typeof value === "bigint")
            return typescript_1.default.factory.createLiteralTypeNode(value < BigInt(0)
                ? typescript_1.default.factory.createPrefixUnaryExpression(typescript_1.default.SyntaxKind.MinusToken, typescript_1.default.factory.createBigIntLiteral((-value).toString()))
                : typescript_1.default.factory.createBigIntLiteral(value.toString()));
        else if (typeof value === "number")
            return typescript_1.default.factory.createLiteralTypeNode(ExpressionFactory_1.ExpressionFactory.number(value));
        return typescript_1.default.factory.createLiteralTypeNode(typescript_1.default.factory.createStringLiteral(value));
    };
    const write_template = (config) => (importer) => (meta) => {
        var _a;
        const head = meta[0].isSoleLiteral();
        const spans = [];
        for (const elem of meta.slice(head ? 1 : 0)) {
            const last = (_a = spans.at(-1)) !== null && _a !== void 0 ? _a : (() => {
                const tuple = [null, null];
                spans.push(tuple);
                return tuple;
            })();
            if (elem.isSoleLiteral())
                if (last[1] === null)
                    last[1] = String(elem.constants[0].values[0]);
                else
                    spans.push([
                        typescript_1.default.factory.createLiteralTypeNode(typescript_1.default.factory.createStringLiteral(String(elem.constants[0].values[0]))),
                        null,
                    ]);
            else if (last[0] === null)
                last[0] = SdkTypeProgrammer.write(config)(importer)(elem);
            else
                spans.push([SdkTypeProgrammer.write(config)(importer)(elem), null]);
        }
        return typescript_1.default.factory.createTemplateLiteralType(typescript_1.default.factory.createTemplateHead(head ? meta[0].constants[0].values[0] : ""), spans
            .filter(([node]) => node !== null)
            .map(([node, str], i, array) => typescript_1.default.factory.createTemplateLiteralTypeSpan(node, (i !== array.length - 1
            ? typescript_1.default.factory.createTemplateMiddle
            : typescript_1.default.factory.createTemplateTail)(str !== null && str !== void 0 ? str : ""))));
    };
    const write_atomic = (importer) => (meta) => write_type_tag_matrix(importer)(typescript_1.default.factory.createKeywordTypeNode(meta.type === "boolean"
        ? typescript_1.default.SyntaxKind.BooleanKeyword
        : meta.type === "bigint"
            ? typescript_1.default.SyntaxKind.BigIntKeyword
            : meta.type === "number"
                ? typescript_1.default.SyntaxKind.NumberKeyword
                : typescript_1.default.SyntaxKind.StringKeyword), meta.tags);
    /* -----------------------------------------------------------
      INSTANCES
    ----------------------------------------------------------- */
    const write_array = (config) => (importer) => (meta) => write_type_tag_matrix(importer)(typescript_1.default.factory.createArrayTypeNode(SdkTypeProgrammer.write(config)(importer)(meta.type.value)), meta.tags);
    const write_tuple = (config) => (importer) => (meta) => typescript_1.default.factory.createTupleTypeNode(meta.type.elements.map((elem) => elem.rest
        ? typescript_1.default.factory.createRestTypeNode(typescript_1.default.factory.createArrayTypeNode(SdkTypeProgrammer.write(config)(importer)(elem.rest)))
        : elem.optional
            ? typescript_1.default.factory.createOptionalTypeNode(SdkTypeProgrammer.write(config)(importer)(elem))
            : SdkTypeProgrammer.write(config)(importer)(elem)));
    const write_regular_property = (config) => (importer) => (properties) => typescript_1.default.factory.createTypeLiteralNode(properties.map((p) => FilePrinter_1.FilePrinter.description(typescript_1.default.factory.createPropertySignature(undefined, Escaper_1.Escaper.variable(String(p.key.constants[0].values[0]))
        ? typescript_1.default.factory.createIdentifier(String(p.key.constants[0].values[0]))
        : typescript_1.default.factory.createStringLiteral(String(p.key.constants[0].values[0])), p.value.isRequired() === false
        ? typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.QuestionToken)
        : undefined, SdkTypeProgrammer.write(config)(importer)(p.value)), writeComment(p.value.atomics)(p.description, p.jsDocTags))));
    const write_dynamic_property = (config) => (importer) => (property) => typescript_1.default.factory.createTypeLiteralNode([
        FilePrinter_1.FilePrinter.description(typescript_1.default.factory.createIndexSignature(undefined, [
            typescript_1.default.factory.createParameterDeclaration(undefined, undefined, typescript_1.default.factory.createIdentifier("key"), undefined, SdkTypeProgrammer.write(config)(importer)(property.key)),
        ], SdkTypeProgrammer.write(config)(importer)(property.value)), writeComment(property.value.atomics)(property.description, property.jsDocTags)),
    ]);
    const write_alias = (config) => (importer) => (meta) => {
        importInternalFile(config)(importer)(meta.name);
        return typescript_1.default.factory.createTypeReferenceNode(meta.name);
    };
    const write_native = (name) => typescript_1.default.factory.createTypeReferenceNode(name);
    /* -----------------------------------------------------------
      MISCELLANEOUS
    ----------------------------------------------------------- */
    const write_type_tag_matrix = (importer) => (base, matrix) => {
        matrix = matrix.filter((row) => row.length !== 0);
        if (matrix.length === 0)
            return base;
        else if (matrix.length === 1)
            return typescript_1.default.factory.createIntersectionTypeNode([
                base,
                ...matrix[0].map((tag) => writeTag(importer)(tag)),
            ]);
        return typescript_1.default.factory.createIntersectionTypeNode([
            base,
            typescript_1.default.factory.createUnionTypeNode(matrix.map((row) => row.length === 1
                ? writeTag(importer)(row[0])
                : typescript_1.default.factory.createIntersectionTypeNode(row.map((tag) => writeTag(importer)(tag))))),
        ]);
    };
})(SdkTypeProgrammer || (exports.SdkTypeProgrammer = SdkTypeProgrammer = {}));
const writeNode = (text) => typescript_1.default.factory.createTypeReferenceNode(text);
const writeTag = (importer) => (tag) => {
    const instance = tag.name.split("<")[0];
    return typescript_1.default.factory.createTypeReferenceNode(importer.external({
        type: true,
        library: `typia/lib/tags/${instance}`,
        instance,
    }), [
        typescript_1.default.factory.createLiteralTypeNode(typeof tag.value === "boolean"
            ? tag.value
                ? typescript_1.default.factory.createTrue()
                : typescript_1.default.factory.createFalse()
            : typeof tag.value === "bigint"
                ? tag.value < BigInt(0)
                    ? typescript_1.default.factory.createPrefixUnaryExpression(typescript_1.default.SyntaxKind.MinusToken, typescript_1.default.factory.createBigIntLiteral((-tag.value).toString()))
                    : typescript_1.default.factory.createBigIntLiteral(tag.value.toString())
                : typeof tag.value === "number"
                    ? ExpressionFactory_1.ExpressionFactory.number(tag.value)
                    : typescript_1.default.factory.createStringLiteral(tag.value)),
    ]);
};
const writeComment = (atomics) => (description, jsDocTags) => {
    const lines = [];
    if (description === null || description === void 0 ? void 0 : description.length)
        lines.push(...description.split("\n").map((s) => `${s}`));
    const filtered = !!atomics.length && !!(jsDocTags === null || jsDocTags === void 0 ? void 0 : jsDocTags.length)
        ? jsDocTags.filter((tag) => !atomics.some((a) => a.tags.some((r) => r.some((t) => t.kind === tag.name))))
        : jsDocTags !== null && jsDocTags !== void 0 ? jsDocTags : [];
    if ((description === null || description === void 0 ? void 0 : description.length) && filtered.length)
        lines.push("");
    if (filtered.length)
        lines.push(...filtered.map((t) => {
            var _a;
            return ((_a = t.text) === null || _a === void 0 ? void 0 : _a.length)
                ? `@${t.name} ${t.text.map((e) => e.text).join("")}`
                : `@${t.name}`;
        }));
    return lines.join("\n");
};
const importInternalFile = (config) => (importer) => (name) => {
    const top = name.split(".")[0];
    if (importer.file === `${config.output}/structures/${top}.ts`)
        return;
    importer.internal({
        type: true,
        file: `${config.output}/structures/${name.split(".")[0]}`,
        instance: top,
    });
};
//# sourceMappingURL=SdkTypeProgrammer.js.map