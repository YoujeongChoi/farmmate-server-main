"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkFunctionProgrammer = void 0;
const typescript_1 = __importDefault(require("typescript"));
const typia_1 = __importDefault(require("typia"));
const IdentifierFactory_1 = require("typia/lib/factories/IdentifierFactory");
const StringUtil_1 = require("../../utils/StringUtil");
const SdkImportWizard_1 = require("./SdkImportWizard");
const SdkTypeProgrammer_1 = require("./SdkTypeProgrammer");
var SdkFunctionProgrammer;
(function (SdkFunctionProgrammer) {
    SdkFunctionProgrammer.write = (config) => (importer) => (route, props) => {
        return typescript_1.default.factory.createFunctionDeclaration([
            typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.ExportKeyword),
            typescript_1.default.factory.createModifier(typescript_1.default.SyntaxKind.AsyncKeyword),
        ], undefined, route.name, undefined, [
            IdentifierFactory_1.IdentifierFactory.parameter("connection", typescript_1.default.factory.createTypeReferenceNode(SdkImportWizard_1.SdkImportWizard.IConnection(importer), props.headers
                ? [typescript_1.default.factory.createTypeReferenceNode(`${route.name}.Headers`)]
                : undefined)),
            ...route.parameters
                .filter((p) => p.category !== "headers")
                .map((p) => typescript_1.default.factory.createParameterDeclaration([], undefined, p.name, p.optional
                ? typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.QuestionToken)
                : undefined, config.primitive !== false &&
                (p === props.query || p === props.input)
                ? typescript_1.default.factory.createTypeReferenceNode(`${route.name}.${p === props.query ? "Query" : "Input"}`)
                : getTypeName(config)(importer)(p))),
        ], typescript_1.default.factory.createTypeReferenceNode("Promise", [
            getReturnType(config)(route),
        ]), typescript_1.default.factory.createBlock(write_body(config)(importer)(route, props), true));
    };
    const write_body = (config) => (importer) => (route, props) => {
        const encrypted = route.encrypted === true ||
            (props.input !== undefined &&
                props.input.custom === true &&
                props.input.category === "body" &&
                props.input.encrypted === true);
        const contentType = props.input !== undefined
            ? (input => {
                const $io0 = input => true === input.custom && "body" === input.category && "number" === typeof input.index && "string" === typeof input.name && (undefined === input.field || "string" === typeof input.field) && "boolean" === typeof input.encrypted && ("application/json" === input.contentType || "text/plain" === input.contentType || "application/x-www-form-urlencoded" === input.contentType || "multipart/form-data" === input.contentType);
                return "object" === typeof input && null !== input && $io0(input);
            })(props.input) ? props.input.contentType
                : "application/json"
            : undefined;
        const caller = () => typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.access(typescript_1.default.factory.createIdentifier(SdkImportWizard_1.SdkImportWizard.Fetcher(encrypted)(importer)))(config.propagate ? "propagate" : "fetch"), undefined, [
            contentType && contentType !== "multipart/form-data"
                ? typescript_1.default.factory.createObjectLiteralExpression([
                    typescript_1.default.factory.createSpreadAssignment(typescript_1.default.factory.createIdentifier("connection")),
                    typescript_1.default.factory.createPropertyAssignment("headers", typescript_1.default.factory.createObjectLiteralExpression([
                        typescript_1.default.factory.createSpreadAssignment(IdentifierFactory_1.IdentifierFactory.access(typescript_1.default.factory.createIdentifier("connection"))("headers")),
                        typescript_1.default.factory.createPropertyAssignment(typescript_1.default.factory.createStringLiteral("Content-Type"), typescript_1.default.factory.createStringLiteral(contentType)),
                    ], true)),
                ], true)
                : typescript_1.default.factory.createIdentifier("connection"),
            typescript_1.default.factory.createObjectLiteralExpression([
                typescript_1.default.factory.createSpreadAssignment(IdentifierFactory_1.IdentifierFactory.access(typescript_1.default.factory.createIdentifier(route.name))("METADATA")),
                typescript_1.default.factory.createPropertyAssignment("path", typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.access(typescript_1.default.factory.createIdentifier(route.name))("path"), undefined, route.parameters
                    .filter((p) => p.category === "param" || p.category === "query")
                    .map((p) => typescript_1.default.factory.createIdentifier(p.name)))),
            ], true),
            ...(props.input
                ? [typescript_1.default.factory.createIdentifier(props.input.name)]
                : []),
            ...(config.json && (input => {
                const $io0 = input => true === input.custom && "body" === input.category && "number" === typeof input.index && "string" === typeof input.name && (undefined === input.field || "string" === typeof input.field) && "boolean" === typeof input.encrypted && ("application/json" === input.contentType || "text/plain" === input.contentType || "application/x-www-form-urlencoded" === input.contentType || "multipart/form-data" === input.contentType);
                return "object" === typeof input && null !== input && $io0(input);
            })(props.input) &&
                (props.input.contentType === "application/json" ||
                    props.input.encrypted === true)
                ? [typescript_1.default.factory.createIdentifier(`${route.name}.stringify`)]
                : []),
        ]);
        const output = (awaiter) => config.simulate
            ? typescript_1.default.factory.createConditionalExpression(typescript_1.default.factory.createIdentifier("!!connection.simulate"), undefined, typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier(`${route.name}.simulate`), [], [
                typescript_1.default.factory.createIdentifier("connection"),
                ...route.parameters
                    .filter((p) => p.category !== "headers")
                    .map((p) => typescript_1.default.factory.createIdentifier(p.name)),
            ]), undefined, awaiter ? typescript_1.default.factory.createAwaitExpression(caller()) : caller())
            : awaiter
                ? typescript_1.default.factory.createAwaitExpression(caller())
                : caller();
        return [
            ...(config.assert
                ? route.parameters
                    .filter((p) => p.category !== "headers")
                    .map((p) => typescript_1.default.factory.createExpressionStatement(typescript_1.default.factory.createCallExpression(IdentifierFactory_1.IdentifierFactory.access(typescript_1.default.factory.createIdentifier(SdkImportWizard_1.SdkImportWizard.typia(importer)))("assert"), [
                    typescript_1.default.factory.createTypeQueryNode(typescript_1.default.factory.createIdentifier(p.name)),
                ], [typescript_1.default.factory.createIdentifier(p.name)])))
                : []),
            ...(route.setHeaders.length === 0
                ? [typescript_1.default.factory.createReturnStatement(output(false))]
                : write_set_headers(config)(route)(output(true))),
        ];
    };
    const write_set_headers = (config) => (route) => (condition) => {
        const accessor = (x) => (y) => x[0] === "[" ? `${x}${y}` : `${x}.${y}`;
        const output = StringUtil_1.StringUtil.escapeDuplicate([
            "connection",
            ...route.parameters.map((p) => p.name),
        ])("output");
        const headers = accessor("connection")("headers");
        const data = config.propagate ? accessor(output)("data") : output;
        const assigners = [
            typescript_1.default.factory.createBinaryExpression(typescript_1.default.factory.createIdentifier(headers), typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.QuestionQuestionEqualsToken), typescript_1.default.factory.createObjectLiteralExpression([])),
            ...route.setHeaders.map((tuple) => {
                var _a;
                return tuple.type === "assigner"
                    ? typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier("Object.assign"), [], [
                        typescript_1.default.factory.createIdentifier(headers),
                        typescript_1.default.factory.createIdentifier(accessor(data)(tuple.source)),
                    ])
                    : typescript_1.default.factory.createBinaryExpression(typescript_1.default.factory.createIdentifier(accessor(headers)((_a = tuple.target) !== null && _a !== void 0 ? _a : tuple.source)), typescript_1.default.factory.createToken(typescript_1.default.SyntaxKind.EqualsToken), typescript_1.default.factory.createIdentifier(accessor(data)(tuple.source)));
            }),
        ].map(typescript_1.default.factory.createExpressionStatement);
        return [
            typescript_1.default.factory.createVariableStatement([], typescript_1.default.factory.createVariableDeclarationList([
                typescript_1.default.factory.createVariableDeclaration(output, undefined, getReturnType(config)(route), condition),
            ], typescript_1.default.NodeFlags.Const)),
            ...(config.propagate
                ? [
                    typescript_1.default.factory.createIfStatement(typescript_1.default.factory.createIdentifier(accessor(output)("success")), assigners.length === 1
                        ? assigners[0]
                        : typescript_1.default.factory.createBlock(assigners, true), undefined),
                ]
                : assigners),
            typescript_1.default.factory.createReturnStatement(typescript_1.default.factory.createIdentifier(output)),
        ];
    };
})(SdkFunctionProgrammer || (exports.SdkFunctionProgrammer = SdkFunctionProgrammer = {}));
const getTypeName = (config) => (importer) => (p) => p.metadata
    ? SdkTypeProgrammer_1.SdkTypeProgrammer.write(config)(importer)(p.metadata)
    : typescript_1.default.factory.createTypeReferenceNode(p.typeName);
const getReturnType = (config) => (route) => typescript_1.default.factory.createTypeReferenceNode(config.propagate !== true && route.output.typeName === "void"
    ? "void"
    : `${route.name}.Output`);
//# sourceMappingURL=SdkFunctionProgrammer.js.map