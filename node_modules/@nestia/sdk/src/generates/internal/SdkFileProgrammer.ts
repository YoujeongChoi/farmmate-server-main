import fs from "fs";
import ts from "typescript";

import { INestiaConfig } from "../../INestiaConfig";
import { IRoute } from "../../structures/IRoute";
import { MapUtil } from "../../utils/MapUtil";
import { FilePrinter } from "./FilePrinter";
import { ImportDictionary } from "./ImportDictionary";
import { SdkRouteDirectory } from "./SdkRouteDirectory";
import { SdkRouteProgrammer } from "./SdkRouteProgrammer";

export namespace SdkFileProgrammer {
  /* ---------------------------------------------------------
        CONSTRUCTOR
    --------------------------------------------------------- */
  export const generate =
    (checker: ts.TypeChecker) =>
    (config: INestiaConfig) =>
    async (routeList: IRoute[]): Promise<void> => {
      // CONSTRUCT FOLDER TREE
      const root: SdkRouteDirectory = new SdkRouteDirectory(null, "functional");
      for (const route of routeList) emplace(root)(route);

      // ITERATE FILES
      await iterate(checker)(config)(root)(config.output + "/functional");
    };

  const emplace =
    (directory: SdkRouteDirectory) =>
    (route: IRoute): void => {
      // OPEN DIRECTORIES
      for (const key of route.accessors.slice(0, -1)) {
        directory = MapUtil.take(
          directory.children,
          key,
          () => new SdkRouteDirectory(directory, key),
        );
      }

      // ADD ROUTE
      directory.routes.push(route);
    };

  /* ---------------------------------------------------------
        FILE ITERATOR
    --------------------------------------------------------- */
  const iterate =
    (checker: ts.TypeChecker) =>
    (config: INestiaConfig) =>
    (directory: SdkRouteDirectory) =>
    async (outDir: string): Promise<void> => {
      // CREATE A NEW DIRECTORY
      try {
        await fs.promises.mkdir(outDir);
      } catch {}

      // ITERATE CHILDREN
      const statements: ts.Statement[] = [];
      for (const [key, value] of directory.children) {
        await iterate(checker)(config)(value)(`${outDir}/${key}`);
        statements.push(
          ts.factory.createExportDeclaration(
            undefined,
            false,
            ts.factory.createNamespaceExport(ts.factory.createIdentifier(key)),
            ts.factory.createStringLiteral(`./${key}`),
            undefined,
          ),
        );
      }
      if (statements.length && directory.routes.length)
        statements.push(FilePrinter.enter());

      // ITERATE ROUTES
      const importer: ImportDictionary = new ImportDictionary(
        `${outDir}/index.ts`,
      );
      directory.routes.forEach((route, i) => {
        if (config.clone !== true)
          for (const tuple of route.imports)
            for (const instance of tuple[1])
              importer.internal({
                file: tuple[0],
                instance,
                type: true,
              });
        statements.push(
          ...SdkRouteProgrammer.generate(checker)(config)(importer)(route),
        );
        if (i !== directory.routes.length - 1)
          statements.push(FilePrinter.enter());
      });

      // FINALIZE THE CONTENT
      if (directory.routes.length !== 0)
        statements.push(
          ...importer.toStatements(outDir),
          ...(!importer.empty() && statements.length
            ? [FilePrinter.enter()]
            : []),
          ...statements.splice(0, statements.length),
        );
      await FilePrinter.write({
        location: importer.file,
        statements,
        top:
          "/**\n" +
          " * @packageDocumentation\n" +
          ` * @module ${directory.module}\n` +
          " * @nestia Generated by Nestia - https://github.com/samchon/nestia \n" +
          " */\n" +
          "//================================================================\n",
      });
    };
}
